<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lua Examples</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <header>
        <h1>Lua Example Programs</h1>
        <nav>
            <ul>
                <li><a href="index.html">Home</a></li>
                <li><a href="history.html">History</a></li>
                <li><a href="resources.html">Resources</a></li>
                <li><a href="examples.html">Examples</a></li>
                <li><a href="comparison.html">Comparison</a></li>
            </ul>
        </nav>
    </header>

    <main>
<p>To run any of the examples, you need to have Lua installed on your system. You can refer to the Installation section of this website.</p>
<p>In the case of the Fork (Calling C from Lua) example, you need a C compiler, like the GNU C Compiler (GCC) and a UNIX-like operating system. If you want to run the example on another operating system like Windows or MacOS, then my challenge to you is to adjust the example to make it work for your system.</p>
<p>In the case of the Blinking LED (Embedded Lua) example, you need a cross compiler that can compile binaries for ARM architectures (<code>arm-none-eabi</code>).</p>
<h4>Input/Output</h4>
<p>Lua has very simple functions for receiving input and writing output.</p>
<h5>Simple Output</h5>
<p>The function to print to <code>stdout</code> is built in. There's no need to import any external modules like in C or Java.</p>
<h6>Code</h6>
<pre><code><span>-- simple-output.lua</span>

<span>-- No other imports.</span>

<span>print</span><span>(</span><span>"Hello, world!"</span><span>)</span>

<span>--[[
Expected output:
Hello, world!
]]</span>
</code></pre>
<h6>Running</h6>
<pre><code>$ lua simple-output.lua
</code></pre>
<h5>Formatted Output</h5>
<p>The <code>string.format()</code> function can be used to create formatted strings from other data types.</p>
<h6>Code</h6>
<pre><code><span>-- formatted-output.lua</span>

<span>local</span> number <span>=</span> <span>15</span>

<span>-- %X displays numbers in hexadecimal format.</span>
<span>print</span><span>(</span>string<span>.</span><span>format</span><span>(</span><span>"%X"</span><span>,</span> number<span>)</span><span>)</span>
</code></pre>
<h6>Running</h6>
<pre><code>$ lua formatted-output.lua
</code></pre>
<h4>Loops</h4>
<h5>Numeric Loops</h5>
<p>The syntax of numeric loops is very simple.</p>
<h6>Code</h6>
<pre><code><span>-- numeric-loops.lua</span>

<span>-- The third 1 is the step, or by how much i changes each iteration.</span>
<span>for</span> i <span>=</span> <span>1</span><span>,</span> <span>5</span><span>,</span> <span>1</span> <span>do</span>
	<span>print</span><span>(</span><span>"Iteration:"</span><span>,</span> i<span>)</span>
<span>end</span>

<span>--[[
Expected output:
1
2
3
4
5
]]</span>
</code></pre>
<h6>Running</h6>
<pre><code>$ lua numeric-loops.lua
</code></pre>
<h5>Generic Loops</h5>
<p>The other use for loops in Lua is iterating over data. Again, the syntax for doing so is very simple. This is also where Lua's most versatile data structure can be introduced: tables.</p>
<h6>Code</h6>
<pre><code><span>--[[
Arrays in Lua are really just tables with key-value pairs. The keys and the values can be of different data types. By convention, keys start at 1 and increment by one (unlike other languages which typically start at index 0).

Another language with an array data type that behaves in almost the exact same way as Lua is PHP, so if you're familiar with PHP then this will make 
]]</span>
a <span>=</span> <span>{</span><span>"a"</span><span>,</span> <span>"b"</span><span>,</span> <span>"c"</span><span>}</span> <span>-- Equivalent to {[1] = "a", [2] = "b", [3] = "c"}</span>

<span>--[[
Here, the ipairs() function is a stateless iterator. Iterators are typically implemented as closures in Lua.

You can read all about stateless iterators like ipairs() here: https://www.lua.org/pil/7.3.html.
]]</span>
<span>for</span> key<span>,</span> value <span>in</span> <span>ipairs</span><span>(</span>a<span>)</span> <span>do</span>
    <span>print</span><span>(</span>key<span>,</span> value<span>)</span>
<span>end</span>

<span>--[[
Expected output:
a
b
c
]]</span>
</code></pre>
<h6>Running</h6>
<pre><code>$ lua generic-loops.lua
</code></pre>
<h4>Functions</h4>
<p>Functions are first-class in Lua, meaning they can be stored in variables, passed to functions, and returned from functions like any other variable.</p>
<h5>Simple Function</h5>
<p>The most basic usage of a function is, of course, defining it and calling it.</p>
<h6>Code</h6>
<pre><code><span>-- A simple greet function.</span>
<span>function</span> <span>greet</span> <span>(</span>name<span>)</span>
	<span>-- Notice how the operator to concatenate strings is ..</span>
	<span>print</span><span>(</span><span>"Hello, "</span> <span>..</span> name <span>..</span> <span>"!"</span><span>)</span>
<span>end</span>

<span>greet</span><span>(</span><span>"Saxton"</span><span>)</span>

<span>--[[
Expected output:
Hello, Saxton!
]]</span>
</code></pre>
<h6>Running</h6>
<pre><code>$ lua simple-function.lua
</code></pre>
<h5>Custom Iterator</h5>
<p>This is where the real power of Lua's functions is shown. This is an example of a custom iterator being implemented as a closure. This iterator can be used in generic loops.</p>
<h6>Code</h6>
<pre><code><span>-- custom-iterator.lua</span>

<span>-- This is an array-like table of three numbers.</span>
a <span>=</span> <span>{</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>}</span>

<span>--[[
A stateless iterator which iterates over an array backwards.

Iterators return three things:
1. The actual function which iterates through an array. 
2. The invariant state (what doesn't change from iteration to iteration).
3. The initial value of our control variable.
]]</span>
<span>function</span> <span>rpairs</span> <span>(</span>a<span>)</span>
    <span>-- A closure is used to get the next value of the array.</span>
    <span>return</span> <span>function</span> <span>(</span>_a<span>,</span> i<span>)</span>
        i <span>=</span> i <span>-</span> <span>1</span>
        <span>local</span> v <span>=</span> _a<span>[</span>i<span>]</span>
        <span>if</span> v <span>then</span>
            <span>return</span> i<span>,</span> v
        <span>end</span>
    <span>end</span><span>,</span> a<span>,</span> <span>#</span>a <span>+</span> <span>1</span>
<span>end</span>

<span>-- A generic loop uses the rpairs() iterator to iterate through the table in reverse order.</span>
<span>for</span> _<span>,</span> value <span>in</span> <span>rpairs</span><span>(</span>a<span>)</span> <span>do</span>
    <span>print</span><span>(</span>value<span>)</span>
<span>end</span>

<span>--[[
Expected output:
3
2
1
]]</span>
</code></pre>
<h6>Running</h6>
<pre><code>$ lua custom-iterator.lua
</code></pre>
<h5>Variable Arguments 1</h5>
<p>Functions can be defined to take a variable number of arguments. You refer to that list of arguments with <code>...</code>.</p>
<h6>Code</h6>
<pre><code><span>-- variable-arguments-1.lua</span>

<span>-- Add up a variable list of arguments (numbers).</span>
<span>function</span> <span>sum</span> <span>(</span><span>...</span><span>)</span>
	<span>local</span> total <span>=</span> <span>0</span>

	<span>-- Create a table using the list of arguments and iterate through it.</span>
	<span>for</span> _<span>,</span> v <span>in</span> <span>ipairs</span><span>(</span><span>{</span><span>...</span><span>}</span><span>)</span> <span>do</span>
		total <span>=</span> total <span>+</span> v
	<span>end</span>
	
	<span>return</span> total
<span>end</span>

<span>print</span><span>(</span><span>sum</span><span>(</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>)</span><span>)</span>

<span>--[[
Expected output:
5
]]</span>
</code></pre>
<h6>Running</h6>
<pre><code>$ lua variable-arguments-1.lua
</code></pre>
<h5>Variable Arguments 2</h5>
<p>If you want to get a specific argument at a certain position, you can use the built-in <code>select()</code> function.</p>
<h6>Code</h6>
<pre><code><span>-- variable-arguments-2.lua</span>

<span>-- Get the third argument passed to the function.</span>
<span>function</span> <span>third</span> <span>(</span><span>...</span><span>)</span>
	<span>-- # can be used to get the number of arguments passed.</span>
	<span>if</span> <span>select</span><span>(</span><span>"#"</span><span>,</span> <span>...</span><span>)</span> <span>&gt;=</span> <span>3</span> <span>then</span>
		<span>return</span> <span>select</span><span>(</span><span>3</span><span>,</span> <span>...</span><span>)</span>
	<span>else</span>
		<span>return</span> <span>nil</span>
	<span>end</span>
<span>end</span>

<span>print</span><span>(</span><span>third</span><span>(</span><span>"a"</span><span>,</span> <span>"b"</span><span>,</span> <span>"c"</span><span>,</span> <span>"d"</span><span>)</span><span>)</span>

<span>--[[
Expected output:
c
]]</span>
</code></pre>
<h6>Running</h6>
<pre><code>$ lua variable-arguments-2.lua
</code></pre>
<h5>"Overloaded" Function</h5>
<p>Lua technically doesn't support overloaded functions. However, you can still call methods even if you don't use the same number of arguments than what the function is defined with. Any missing arguments are set to <code>nil</code>, which can be checked in the function body with conditional logic. So, you can emulate them.</p>
<h6>Code</h6>
<pre><code><span>-- overloaded-function.lua</span>

<span>-- Revisiting the greet function from before.</span>
<span>function</span> <span>greet</span> <span>(</span>name<span>,</span> time<span>)</span>
	<span>-- Only false and nil are falsy. 0 and empty strings are considered true.</span>
	<span>if</span> name <span>and</span> time <span>then</span>
		<span>print</span><span>(</span><span>"Good "</span> <span>..</span> time <span>..</span> <span>", "</span> <span>..</span> name <span>..</span> <span>"!"</span><span>)</span>
	<span>elseif</span> name <span>then</span>
		<span>print</span><span>(</span><span>"Hello, "</span> <span>..</span> name <span>..</span> <span>"!"</span><span>)</span>
	<span>else</span>
		<span>print</span><span>(</span><span>"Hey there!"</span><span>)</span>
	<span>end</span>
<span>end</span>

<span>greet</span><span>(</span><span>)</span>
<span>greet</span><span>(</span><span>"Alice"</span><span>)</span>
<span>greet</span><span>(</span><span>"Alice"</span><span>,</span> <span>"morning"</span><span>)</span>

<span>--[[
Expected output:
Hey there!
Hello, Alice!
Good morning, Alice!
]]</span>
</code></pre>
<h6>Running</h6>
<pre><code>$ lua overloaded-function.lua
</code></pre>
<h4>Object-Oriented Programming</h4>
<p>Lua is sort of a mix between C, Go, and Java when it comes to classes. There's technically no class data structure in the language, just like in C or Go. But, there are still features in the language which help in doing object-oriented programming.</p>
<h5>Simple Class</h5>
<p>This is an example of a "class" in Lua which is a translated version of the Person "class" from the Go example. A very important feature of Lua is introduced with this example: metatables.</p>
<h6>Code</h6>
<pre><code><span>-- simple-class.lua</span>

<span>-- Define a new table for a Person data type.</span>
Person <span>=</span> <span>{</span><span>}</span>

<span>-- Set up the inheritance for instances of Person.</span>
Person<span>.</span>__index <span>=</span> Person

<span>-- Constructor for a new Person.</span>
<span>function</span> Person<span>:</span><span>new</span> <span>(</span>name<span>,</span> age<span>)</span>
    <span>local</span> obj <span>=</span> <span>setmetatable</span><span>(</span><span>{</span><span>}</span><span>,</span> Person<span>)</span>

    obj<span>.</span>name <span>=</span> name
    obj<span>.</span>age <span>=</span> age

    <span>return</span> obj
<span>end</span>

<span>--[[
Getter for the name attribute.

This syntax for defining a function is equivalent to this:
Person["name"] = function (Person) ... end

The table itself is passed as a hidden parameter to the function.
]]</span>
<span>function</span> Person<span>:</span><span>get_name</span> <span>(</span><span>)</span>
    <span>return</span> self<span>.</span>name
<span>end</span>

<span>-- Getter for the age attribute.</span>
<span>function</span> Person<span>:</span><span>get_age</span> <span>(</span><span>)</span>
    <span>return</span> self<span>.</span>age
<span>end</span>

<span>-- Custom function for representing our "class" as a string.</span>
<span>function</span> Person<span>:</span><span>__tostring</span> <span>(</span><span>)</span>
    <span>return</span> self<span>.</span>name <span>..</span> <span>" "</span> <span>..</span> self<span>.</span>age
<span>end</span>

<span>-- Create a new Person.</span>
p <span>=</span> Person<span>:</span><span>new</span><span>(</span><span>"Ana"</span><span>,</span> <span>20</span><span>)</span>
<span>print</span><span>(</span>p<span>:</span><span>get_name</span><span>(</span><span>)</span><span>)</span>
<span>print</span><span>(</span>p<span>:</span><span>get_age</span><span>(</span><span>)</span><span>)</span>
<span>print</span><span>(</span>p<span>)</span>

<span>--[[
Expected output:
Ana
20
Ana 20
]]</span><span>--</span>
</code></pre>
<h6>Running</h6>
<pre><code>$ lua simple-class.lua
</code></pre>
<h6>A Short Explanation of Metatables</h6>
<p>There are two lines which make this sort of class inheritance possible:</p>
<ol>
<li><code>Person.__index = Person</code>.</li>
<li><code>local obj = setmetatable({}, Person)</code>.</li>
</ol>
<p>The second line creates an empty table (<code>{}</code>) with its metatable set to <code>Person</code>. By default, newly created tables don't have a metatable.</p>
<p>What are metatables? Metatables are just tables that hold regular keys (called metafields) like <code>__add</code>, <code>__index</code>, and <code>__tostring</code>. These keys are usually assigned functions (called metamethods). The <code>__index</code> metafield can also be assigned another table or a value that also has an <code>__index</code> metafield.</p>
<p>When you perform an operation like addition (<code>a + b</code>), and one of the operands is a table or userdata (either <code>a</code> or <code>b</code>), the Lua interpreter will check if that table has a metatable set (if both are tables, it checks the left one first and the right one second). If it does have a metatable set, it will check if that metatable has the <code>__add</code> metafield and if it has a function assigned to it. If it does, the interpreter will pass both operands (<code>a</code> and <code>b</code>) to the function and the return value will become the final result of the operation.</p>
<p>If you're trying to retrieve a value from a table with a key, but the table doesn't it, the Lua interpreter checks if that table has a metatable set. If it does have a metatable set, it will check if that metatable has the <code>__index</code> metafield. If it does, then the interpreter behaves differently depending on what is assigned to it. If the <code>__index</code> metafield has been assigned ...</p>
<ul>
<li>A table that doesn't have an <code>__index</code> metafield - The interpreter will check that table for the key being searched and return it. <code>nil</code> is returned otherwise.</li>
<li>A table that also has an <code>__index</code> metafield (a metatable) - The interpreter uses that table as a new metatable and recursively begins the process of searching again.</li>
<li>A function (metamethod) - The interpreter will call it and pass the instance of the original table and the key being searched as arguments.</li>
</ul>
<p>This brings us back to the first line of code. By assigning the <code>__index</code> metafield of the <code>Person</code> table to itself, we're allowing any tables which have <code>Person</code> set as their metatable to access the fields (and their associated values or functions) of <code>Person</code>. </p>
<h4>Complex Examples</h4>
<p>These examples take the concepts demonstrated in the previous examples and combine them into more complex programs. </p>
<h5>Hexdump</h5>
<p>This is a basic hexdump program. It takes the contents of a file through <code>stdin</code> and prints the hexadecimal representation of it to the terminal.</p>
<h6>Code</h6>
<pre><code><span>-- hexdump.lua</span>

<span>-- This is the custom stateless iterator from before.</span>
<span>function</span> <span>rpairs</span> <span>(</span>a<span>)</span>
    <span>return</span> <span>function</span> <span>(</span>_a<span>,</span> i<span>)</span>
        i <span>=</span> i <span>-</span> <span>1</span>
        <span>local</span> v <span>=</span> _a<span>[</span>i<span>]</span>
        <span>if</span> v <span>then</span>
            <span>return</span> i<span>,</span> v
        <span>end</span>
    <span>end</span><span>,</span> a<span>,</span> <span>#</span>a <span>+</span> <span>1</span>
<span>end</span>

<span>-- Get the content from stdin.</span>
<span>local</span> stdin <span>=</span> io<span>.</span><span>read</span><span>(</span><span>"*all"</span><span>)</span>

<span>-- Specify the number of columns and the group size.</span>
<span>local</span> columns <span>=</span> <span>8</span>
<span>local</span> group_size <span>=</span> <span>2</span>

<span>-- If the group size is even, we need to make the ending offset odd.</span>
<span>local</span> ending_offset <span>=</span> <span>0</span>
<span>if</span> group_size <span>%</span> <span>2</span> <span>==</span> <span>0</span> <span>then</span>
    ending_offset <span>=</span> <span>1</span>
<span>end</span>

<span>-- Loop through the file group_size characters at a time.</span>
<span>for</span> i <span>=</span> group_size<span>,</span> <span>#</span>stdin <span>+</span> ending_offset<span>,</span> group_size <span>do</span>

    <span>-- Print the current position within the file.</span>
    <span>if</span> <span>(</span>i <span>-</span> group_size<span>)</span> <span>%</span> <span>(</span>group_size <span>*</span> columns<span>)</span> <span>==</span> <span>0</span> <span>then</span>
        <span>if</span> <span>(</span>i <span>-</span> group_size<span>)</span> <span>&gt;</span> group_size <span>then</span>
            <span>print</span><span>(</span><span>""</span><span>)</span>
        <span>end</span>

        io<span>.</span><span>write</span><span>(</span>string<span>.</span><span>format</span><span>(</span><span>"%07X "</span><span>,</span> i <span>-</span> group_size<span>)</span><span>)</span>
    <span>end</span>

    <span>-- Get the current character and previous character at the current position.</span>
    <span>local</span> characters <span>=</span> <span>{</span><span>}</span>
    <span>for</span> j <span>=</span> <span>1</span><span>,</span> group_size <span>do</span>
        <span>local</span> character_position <span>=</span> i <span>-</span> group_size <span>+</span> j
        <span>local</span> character <span>=</span> string<span>.</span><span>byte</span><span>(</span>stdin<span>:</span><span>sub</span><span>(</span>character_position<span>,</span> character_position<span>)</span><span>)</span>
        <span>if</span> character <span>then</span>
            characters<span>[</span>j<span>]</span> <span>=</span> character
        <span>else</span>
            characters<span>[</span>j<span>]</span> <span>=</span> <span>0</span>
        <span>end</span>
    <span>end</span>

    <span>-- Print the characters as a hexadecimal group.</span>
    <span>for</span> _<span>,</span> character <span>in</span> <span>rpairs</span><span>(</span>characters<span>)</span> <span>do</span>
        io<span>.</span><span>write</span><span>(</span>string<span>.</span><span>format</span><span>(</span><span>"%02X"</span><span>,</span> character<span>)</span><span>)</span>
    <span>end</span>
    io<span>.</span><span>write</span><span>(</span><span>" "</span><span>)</span>
<span>end</span>
</code></pre>
<h6>Running</h6>
<p>If you have the actual hexdump program installed on your system, you can verify its accuracy by running and comparing the output of both.</p>
<pre><code>$ hexdump hexdump.lua
0000000 2d0a 202d <span>6568</span> <span>6478</span> 6d75 2e70 756c 0a61
0000010 2d0a 202d <span>6854</span> <span>7369</span> <span>6920</span> <span>2073</span> <span>6874</span> <span>2065</span>
<span>..</span>.

$ <span>cat</span> hexdump.lua <span>|</span> lua hexdump.lua
0000000 2D0A 202D <span>6568</span> <span>6478</span> 6D75 2E70 756C 0A61 
0000010 2D0A 202D <span>6854</span> <span>7369</span> <span>6920</span> <span>2073</span> <span>6874</span> <span>2065</span>
<span>..</span>.
</code></pre>
<h5>Fork (Calling C from Lua)</h5>
<p>To write C code that can be interacted with from Lua, all you need to do is include the Lua header files in your C program, include the necessary functions in your C code, and compile it as a shared library. You can then import that shared library in your Lua script using <code>require</code> as if it was written in Lua.</p>
<p>In this example, there's a C function named <code>lua_fork</code> which wraps around the <code>fork()</code> function of the POSIX operating system API (<code>unistd.h</code>). Calling <code>fork()</code> duplicates the current process and makes it a child process. The value of <code>fork()</code> is different for the parent process and the child process, allowing you to write code that only executes in parent process and / or the child.</p>
<p>The <code>fork()</code> function isn't available in Lua because:</p>
<ul>
<li>Lua is meant to be portable - Low-level functions that aren't available on all operating systems, like <code>fork()</code>, make code less portable.</li>
<li>Lua is meant to be extended - For any primitives or low-level functionality you need, the creators of Lua expected you to use C.</li>
</ul>
<h6>Code</h6>
<pre><code>$ <span>ls</span>
Makefile example.lua lua_fork.c
</code></pre>
<pre><code><span># Makefile</span>

<span># Build configuration. Replace with values relevant to your system.</span>
CC <span>=</span> gcc
CFLAGS <span>=</span> -O2 -fPIC -shared
INCLUDES <span>=</span> /usr/<span>include</span>/lua5.4
MODULE_NAME <span>=</span> lua_fork
SCRIPT_NAME <span>=</span> example

<span>.PHONY</span><span>:</span> run

<span># Run the Lua script.</span>
<span>run</span><span>:</span> lua_fork.so
	lua <span>$</span><span>(</span>SCRIPT_NAME<span>)</span>.lua

<span># Build the shared library.</span>
<span>lua_fork.so</span><span>:</span> lua_fork.c
	<span>$</span><span>(</span>CC<span>)</span> <span>$</span><span>(</span>CFLAGS<span>)</span> -o <span>$</span><span>(</span>MODULE_NAME<span>)</span>.so <span>$</span><span>(</span>MODULE_NAME<span>)</span>.c -I<span>$</span><span>(</span>INCLUDES<span>)</span>
</code></pre>
<pre><code><span>-- example.lua</span>

<span>-- Import the C module.</span>
<span>local</span> lua_fork <span>=</span> <span>require</span><span>(</span><span>"lua_fork"</span><span>)</span>

<span>-- Run the lua_fork() method.</span>
<span>local</span> pid <span>=</span> lua_fork<span>.</span><span>lua_fork</span><span>(</span><span>)</span><span>;</span>

<span>-- If the pid is 0, that means the code being executed is within the child.</span>
<span>if</span> pid <span>==</span> <span>0</span> <span>then</span>
    <span>print</span><span>(</span><span>"This is the child process."</span><span>)</span>
<span>-- Otherwise, the pid is that of the parent.</span>
<span>else</span>
    <span>print</span><span>(</span><span>"This is the parent process. The child PID is"</span><span>,</span> pid<span>)</span>
<span>end</span>
</code></pre>
<pre><code><span>/* lua_fork.c */</span>

<span>/* Necessary includes. */</span>
<span><span>#</span><span>include</span> <span>&lt;lauxlib.h&gt;</span></span>
<span><span>#</span><span>include</span> <span>&lt;lua.h&gt;</span></span>
<span><span>#</span><span>include</span> <span>&lt;lualib.h&gt;</span></span>
<span><span>#</span><span>include</span> <span>&lt;sys/types.h&gt;</span></span>
<span><span>#</span><span>include</span> <span>&lt;unistd.h&gt;</span></span>

<span>/* Function prototypes. */</span>
<span>int</span> <span>lua_fork</span><span>(</span>lua_State <span>*</span>L<span>)</span><span>;</span>
<span>int</span> <span>luaopen_lua_fork</span><span>(</span>lua_State <span>*</span>L<span>)</span><span>;</span>

<span>/*
Calls the fork() subroutine from the POSIX operating system API.

This function isn't available to Lua because it's a low-level operating system call. One of the purposes for allowing modules to be written in C is so that these types of functions can be made accessible.
*/</span>
<span>int</span>
<span>lua_fork</span><span>(</span>lua_State <span>*</span>L<span>)</span>
<span>{</span>
    <span>/*
    fork() returns a pid_t type. According to the GNU libc manual, pid_t is just an int data type.
    */</span>
    <span>pid_t</span> pid <span>=</span> <span>(</span><span>int</span><span>)</span><span>fork</span><span>(</span><span>)</span><span>;</span>

    <span>/* If the pid is less than 0, it failed. */</span>
    <span>if</span> <span>(</span>pid <span>&lt;</span> <span>0</span><span>)</span>
        <span>return</span> <span>luaL_error</span><span>(</span>L<span>,</span> <span>"fork() failed."</span><span>)</span><span>;</span>

    <span>/* The pid is returned via the lua_State. */</span>
    <span>lua_pushnumber</span><span>(</span>L<span>,</span> pid<span>)</span><span>;</span>

    <span>/* The number of results we're giving back to Lua. */</span>
    <span>return</span> <span>1</span><span>;</span>
<span>}</span>

<span>/*
In order for Lua to recognize the entrypoint of the module, at least one function must be named according to this format: luaopen_&lt;module name&gt;. In the Lua program, you can import the module by writing require(&lt;module name&gt;).
*/</span>
<span>int</span>
<span>luaopen_lua_fork</span><span>(</span>lua_State <span>*</span>L<span>)</span>
<span>{</span>
    <span>/* Create an array of functions which should be accessible from Lua. */</span>
    luaL_Reg functions<span>[</span><span>]</span> <span>=</span> <span>{</span>
        <span>{</span><span>"lua_fork"</span><span>,</span> lua_fork<span>}</span><span>,</span>
        <span>{</span><span>NULL</span><span>,</span> <span>NULL</span><span>}</span>
    <span>}</span><span>;</span>

    <span>/* Add those functions to the Lua state so they're accessible. */</span>
    <span>luaL_newlib</span><span>(</span>L<span>,</span> functions<span>)</span><span>;</span>

    <span>/* The number of results we're giving back to Lua. */</span>
    <span>return</span> <span>1</span><span>;</span>
<span>}</span>
</code></pre>
<h6>Running</h6>
<pre><code>$ <span>make</span>
This is the parent process. The child PID is	XXXXX.0
This is the child process.
</code></pre>
<h5>Blinking LED (Embedded Lua)</h5>
<p>To demonstrate how Lua can be used with embedded systems and microcontrollers, I will use MicroLua to create a small demonstration program which blinks the onboard LED of the Raspberry Pi Pico.</p>
<p>Here is what you need to run this example:</p>
<ul>
<li>The build system used by MicroLua is CMake, so you have to make sure it's installed on your system. MicroLua uses CMake because the Pico SDK uses it.</li>
<li>You need a C/C++ cross-compiler which can compile to ARM targets (<code>arm-none-eabi</code>). The instructions for doing both will depend on your system.</li>
<li>You also need to clone the MicroLua repository from GitHub, save it somewhere on your system, and add an environment variable named <code>MLUA_PATH</code> which points to it.</li>
</ul>
<h6>Code</h6>
<pre><code><span># This is how you would install the dependencies on Gentoo, which is the Linux distribution I use.</span>
$ <span>sudo</span> emerge <span>-av</span> dev-build/cmake sys-devel/crossdev app-eselect/eselect-repository
$ <span>sudo</span> eselect repository create crossdev
$ <span>sudo</span> crossdev <span>--stable</span> <span>--target</span> arm-none-eabi <span>-s4</span>

<span># Once you install the required programs, you can clone MicroLua's repository. I prefer to save source code in my ~/.local/src directory, however you can save it wherever you want.</span>
$ <span>cd</span> ~/.local/src/
$ <span>git</span> clone https://github.com/MicroLua/MicroLua

<span># Add the environment variable to your shell's rc file. The following commands work if you're using Bash.</span>
$ <span>echo</span> <span>'export MLUA_PATH=$HOME/.local/src/MicroLua'</span> <span>&gt;&gt;</span> ~/.bashrc
$ <span>source</span> ~/.bashrc

<span># Create a directory named blink_example to store the example files.</span>
$ <span>cd</span> ~/projects
$ <span>mkdir</span> blink_example
</code></pre>
<p>For all of the files provided below, you need to save them to the <code>blink_example</code> folder.</p>
<pre><code>$ <span>cd</span> blink_example

<span># Save example files to the directory.</span>

$ <span>ls</span>
CMakeLists.txt blink
</code></pre>
<p>Copy the <code>mlua_import.cmake</code> file from the MicroLua repository into this <code>blink_example</code> folder. That file tells CMake where to find MicroLua on our system when it comes time to build the project.</p>
<pre><code><span># CMakeLists.txt</span>

<span># Ensure we meet the minimum required version of CMake.</span>
<span>cmake_minimum_required</span><span>(</span><span>VERSION</span> <span>3.24</span><span>)</span>

<span># This is how our project knows where MicroLua is.</span>
<span>include</span><span>(</span>mlua_import.cmake<span>)</span>

<span># Define our project name, the languages being used, and their versions.</span>
<span>project</span><span>(</span>MicroLua_examples C CXX ASM<span>)</span>
<span>set</span><span>(</span><span>CMAKE_C_STANDARD</span> <span>11</span><span>)</span>
<span>set</span><span>(</span><span>CMAKE_CXX_STANDARD</span> <span>17</span><span>)</span>

<span># Calls an initialization macro from MicroLua's build system.</span>
<span>mlua_init</span><span>(</span><span>)</span>

<span>macro</span><span>(</span>check_vars<span>)</span>
    <span>foreach</span><span>(</span>var <span>${</span>ARGN<span>}</span><span>)</span>
        <span>if</span><span>(</span><span>"<span><span>${</span><span>${</span><span>var</span><span>}</span><span>}</span></span>"</span> <span>STREQUAL</span> <span>""</span><span>)</span>
            <span>file</span><span>(</span>RELATIVE_PATH rel <span>"<span><span>${</span><span>CMAKE_SOURCE_DIR</span><span>}</span></span>"</span>
                 <span>"<span><span>${</span><span>CMAKE_CURRENT_SOURCE_DIR</span><span>}</span></span>"</span><span>)</span>
            <span>message</span><span>(</span><span>"Skipping <span><span>${</span><span>rel</span><span>}</span></span>: <span><span>${</span><span>var</span><span>}</span></span> isn't set"</span><span>)</span>
            <span>return</span><span>(</span><span>)</span>
        <span>endif</span><span>(</span><span>)</span>
    <span>endforeach</span><span>(</span><span>)</span>
<span>endmacro</span><span>(</span><span>)</span>

<span># Preprocessor definitions.</span>
<span>add_compile_definitions</span><span>(</span>
    MLUA_MAIN_SHUTDOWN=<span>1</span>
    MLUA_MAIN_TRACEBACK=<span>1</span>
    PICO_ENTER_USB_BOOT_ON_EXIT=<span>1</span>
    PICO_STACK_SIZE=0x1000
    PICO_USE_STACK_GUARDS=<span>1</span>
<span>)</span>

<span># Add the CMakeLists.txt file in the blink directory.</span>
<span>add_subdirectory</span><span>(</span>blink<span>)</span>
</code></pre>
<pre><code>$ <span>ls</span> blink
CMakeLists.txt blink.lua
</code></pre>
<pre><code><span># blink/CMakeLists.txt</span>

<span># Create a new module based on the blink.lua file.</span>
<span>mlua_add_lua_modules</span><span>(</span>mod_blink blink.lua<span>)</span>

<span># Ensure the required MicroLua libraries are included.</span>
<span>target_link_libraries</span><span>(</span>mod_blink <span>INTERFACE</span>
    mlua_mod_hardware.gpio
    mlua_mod_mlua.time
    mlua_mod_pico
<span>)</span>

<span># Package the program into an executable named blink.</span>
<span>mlua_add_executable</span><span>(</span>blink<span>)</span>

<span># Set the main module as the blink executable.</span>
<span>target_compile_definitions</span><span>(</span>blink <span>PRIVATE</span>
    MLUA_MAIN_MODULE=blink
<span>)</span>

<span># Ensure the required libraries are linked.</span>
<span>target_link_libraries</span><span>(</span>blink <span>PRIVATE</span>
    mod_blink
    pico_stdlib
<span>)</span>
</code></pre>
<pre><code><span>-- blink/blink.lua</span>

<span>-- Necessary includes.</span>
<span>local</span> gpio <span>=</span> require <span>'hardware.gpio'</span>
<span>local</span> time <span>=</span> require <span>'mlua.time'</span>
<span>local</span> pico <span>=</span> require <span>'pico'</span>

<span>-- The pins we're using for our circuit.</span>
<span>local</span> ONBOARD_LED_PIN <span>=</span> <span>25</span>

<span>-- The main method for the program.</span>
<span>function</span> <span>main</span> <span>(</span><span>)</span>
	<span>-- Initialize the pin of the onboard LED to be an output.</span>
	gpio<span>.</span><span>init</span><span>(</span>ONBOARD_LED_PIN<span>)</span>
    gpio<span>.</span><span>set_dir</span><span>(</span>ONBOARD_LED_PIN<span>,</span> gpio<span>.</span>OUT<span>)</span>

	<span>-- Endless loop.</span>
	<span>while</span> <span>true</span> <span>do</span>
		<span>-- Turns on the pin, waits, turns off the pin, and then waits.</span>
		gpio<span>.</span><span>put</span><span>(</span>ONBOARD_LED_PIN<span>,</span> <span>1</span><span>)</span>
        time<span>.</span><span>sleep_for</span><span>(</span><span>500</span> <span>*</span> time<span>.</span>msec<span>)</span>
        gpio<span>.</span><span>put</span><span>(</span>ONBOARD_LED_PIN<span>,</span> <span>0</span><span>)</span>
        time<span>.</span><span>sleep_for</span><span>(</span><span>500</span> <span>*</span> time<span>.</span>msec<span>)</span>
	<span>end</span>
<span>end</span>
</code></pre>
<h6>Running</h6>
<p>To compile this program as a binary executable that can be flashed to the Raspberry Pi Pico, run the following build commands:</p>
<pre><code>$ cmake <span>-S</span> <span>.</span> <span>-B</span> build <span>-DPICO_BOARD</span><span>=</span>pico
$ <span>make</span> <span>-j9</span> <span>-C</span> build
</code></pre>
<p>The program should now be compiled assuming there aren't any errors. Hold down the BOOTSEL button on the Raspberry Pi Pico and plug it into your computer. This makes the Raspberry Pi Pico appear as a flash drive, making it easy to copy the firmware to it. For this example, you need to copy the <code>build/blink.uf2</code> file to the Raspberry Pi Pico. Once the file is copied successfully, the onboard LED should start blinking.</p>

    </main>

    <footer>
        <p>CS 354 Language Website - Created by Team Doves</p>
    </footer>
</body>
</html>
